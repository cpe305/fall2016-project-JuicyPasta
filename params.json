{
  "name": "Fall2016-project-juicypasta",
  "tagline": "honeypot.jacksondarrow.com",
  "body": "Network Honeypot\r\n============\r\n\r\nCPE-305 final project\r\n\r\n[![Build Status](https://travis-ci.org/cpe305/fall2016-project-JuicyPasta.svg?branch=master)](https://travis-ci.org/cpe305/fall2016-project-JuicyPasta)\r\n\r\n### [live website](http://honeypot.jacksondarrow.com:8888/honeypot-1.0)\r\n\r\n\r\n\r\n## Goals\r\n* Connect with random hosts on the internet and log the important details of the interaction. \r\n* Gain insight about the location and behaviors of these hosts (presumed to be bots)\r\n* Design the software in a way that is mindful of archetectural and design principals learned in CPE-305\r\n\r\n## Design\r\n\r\n### Uml Class Diagram\r\n![](https://raw.githubusercontent.com/cpe305/fall2016-project-JuicyPasta/master/docs/Honeypot_Class_Diagram.svg)\r\n\r\n### Two Components Bridged With the Observer Pattern\r\n##### Log Gathering Component - Observable\r\nThe log gathering component is broken up into a number of subdivisions that are subclasses of \"Listener\". These subdivisions are in charge of accepting connections and logging interactions. When the listener determines that the interaction is over, it lets all of its observers know about the log with following.\r\n```java\r\nsetChanged();\r\nnotifyObservers(log);\r\n```\r\n\r\n##### Log Processing Component - Observer\r\nThe log processing component does a lot of the heavy lifting. It is designed in a way that allows for different types of LogConsumers to define the way they aggregate data as logs flow through them. LogConsumers also are able to select what type of logs they are willing to process. Ideally I would have made logs contain a list of \"tags\" that consumers would be able to accept but I did not have the time to refactor this change. \r\n\r\n```java\r\n// Creating a new LogConsumer that keeps track of which countries produce the most http events (country is a property that gets added to the log object, second argument can be any property)\r\nLogConsumer httpRankedByCountry = new RankedAttributeConsumer(\"Top HTTP countries\", \"country\");\r\nhttpRankedByCountry.addAcceptableType(LogType.HTTP_EVENT);\r\n\r\n// Creating a new TCPListener that listens on port 10080 (unprivelaged), new connections will be handled by HTTPService and produces HTTP_EVENT type logs\r\ntcpListener = new TCPListener();\r\ntcpListener.addService(10080, HTTPService::new, ()->new Log(LogType.HTTP_EVENT));\r\n\r\n// Start observing logs\r\ntcpListener.addObserver(httpRankedByCountry);\r\n```\r\n\r\n### factory method pattern\r\nFactory methods are used to create logs and services, simply subclass one of the log factories using java 8 lambdas\r\n```java\r\n// LogFactory.java\r\n@FunctionalInterface\r\npublic interface LogFactory<T extends Log> {\r\n    T create();\r\n}\r\n...\r\n//ServiceFactory.java\r\n@FunctionalInterface\r\npublic interface ServiceFactory<T extends Service> {\r\n    T create();\r\n}\r\n```\r\n\r\n\r\n### singleton pattern\r\nThe ConsumerRegistry uses the singleton pattern so that it can be accessed by the servlets and main class\r\n```java\r\nprivate static ConsumerRegistry INSTANCE = new ConsumerRegistry();\r\npublic static ConsumerRegistry getInstance() {\r\n\treturn INSTANCE;\r\n}\r\n```\r\n\r\n### template pattern - adding new service state machines\r\nThis is the bread and butter of how the honeypot is able to extract information. The template class is the \"Service\" class. This pattern lets me define how I want the different services to behave and log information. The following example shows an HTTPService that redirects the user and logs the length of their payload. A more extensive example would have been a state machine that displays a username and password box that tempts bots into guessing credential pairs. \r\n```java\r\npublic class HTTPService extends Service {\r\n    // Client talks first in HTTP\r\n    @Override\r\n    public String getPreamble() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public String feed(String input) {\r\n        super.getLog().addProperty(\"content-length\", String.valueOf(input.length()));\r\n\r\n        String toRet = \"\" +\r\n                \"HTTP/1.1 302 Found\\n\" +\r\n                \"Location: https://www.google.com\\n\" +\r\n                \"Content-Type: text/html; charset=UTF-8\\n\" +\r\n                \"content-length:226\\n\" +\r\n                \"Accept-Encoding: gzip, deflate, sdch, br\\n\" +\r\n                \"Accept-Language: en-US,en;q=0.8\\n\";\r\n\r\n        return toRet;\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Usage\r\n\r\n##### Method 1 - Using the Maven Tomcat Plugin\r\n\t# clone the repository\r\n    git clone https://github.com/cpe305/fall2016-project-JuicyPasta\r\n   \tcd fall2016-project-JuicyPasta\r\n\tmvn clean install compile tomcat7:run\r\n    \r\n##### Method 2 - Using the Apache Tomcat(8+) Container\r\n\r\n\t# Install Apache Tomcat 8 \r\n    git clone https://github.com/cpe305/fall2016-project-JuicyPasta\r\n    cd fall2016-project-JuicyPasta\r\n    mvn clean install compile war:war\r\n    # upload /target/honeypot-1.0.war to the Apache host-manager\r\n\r\n##### Configuring the network\r\nIn order to setup the Tomcat server in the most secure way possible, we must run all of the honeypot listeners on unprivelaged ports. After you get all of that working, use port forwarding or iptables to proxy the desired service ports to the honeypot ports making sure no NAT is performed. \r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}